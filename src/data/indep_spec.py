# -*- coding: utf-8 -*-"""src/data/indep_spec.pyIndependence-specification + construction of I (pair list).Produces:  - I_full: all discovered/oracle "no-trek" pairs  - I: capped subset (if cap is set)Conventions:  - Pairs are 0-based (i,j) with i<j typically, but we don't enforce order here.  - Returned arrays have shape (m,2) dtype int64 (or empty (0,2))."""from __future__ import annotationsfrom dataclasses import dataclassfrom typing import List, Optional, Sequence, Tuple, Union, Literalfrom src.utils.notreks import get_no_trek_pairsimport numpy as npimport torchPairs = Union[np.ndarray, Sequence[Tuple[int, int]]]@dataclass(frozen=True)class ISpec:    # where to get independencies from    source: Literal["oracle", "pairwise"] = "oracle"    # -------------------------    # pairwise-test settings    # -------------------------    alpha: float = 0.001    test: str = "spearman"    num_perm: int = 500    seed: int = 0    bonferroni: bool = True    undirected: bool = False    # -------------------------    # selection / filtering    # -------------------------    cap: Optional[int] = None    cap_seed: int = 1    min_indeps: int = 1def _as_pairs_array(I: Pairs) -> np.ndarray:    """Convert Pairs -> np.ndarray (m,2) int64, allowing empty."""    I_np = np.asarray(I, dtype=np.int64)    if I_np.size == 0:        return np.zeros((0, 2), dtype=np.int64)    I_np = I_np.reshape(-1, 2)    return I_np.astype(np.int64, copy=False)def cap_pairs(I_full: np.ndarray, cap: Optional[int], *, cap_seed: int = 1) -> np.ndarray:    """Return capped subset (without replacement), deterministic by cap_seed."""    I_full = _as_pairs_array(I_full)    if cap is None:        return I_full    if not isinstance(cap, int) or cap < 0:        raise ValueError("cap must be a nonnegative int or None.")    m = I_full.shape[0]    if cap >= m:        return I_full    rng = np.random.default_rng(int(cap_seed))    idx = rng.choice(m, size=int(cap), replace=False)    return I_full[idx]def build_I_full_and_capped(    *,    X: Optional[np.ndarray],    B_true: np.ndarray,    I_spec: ISpec,    verbose: bool = False,) -> tuple[np.ndarray, np.ndarray]:    """    Build I_full and (optionally capped) I.    Parameters    ----------    X : np.ndarray        Data matrix (n,d). Only used when I_spec.source == "pairwise".    B_true : np.ndarray        True adjacency (d,d), binary. Only used when I_spec.source == "oracle".    I_spec : ISpec        Independence configuration.    verbose : bool        Print capping info.    Returns    -------    (I_full, I) : tuple[np.ndarray, np.ndarray]        Both arrays (m,2) and (m',2), dtype int64.    """    d = int(B_true.shape[0])    if B_true.ndim != 2 or B_true.shape[0] != B_true.shape[1]:        raise ValueError("B_true must be (d,d).")    if I_spec.source == "pairwise":        # lazy import (SciPy only needed here)        from src.utils.mi_tests import get_I_from_full_pairwise_tests        if X.ndim != 2 or X.shape[1] != d:            raise ValueError(f"X must be (n,d) with d={d} matching B_true.")        I_full = get_I_from_full_pairwise_tests(            X,            alpha=I_spec.alpha,            test=I_spec.test,            num_perm=I_spec.num_perm,            seed=I_spec.seed,            bonferroni=I_spec.bonferroni,        )        I_full = _as_pairs_array(I_full)    elif I_spec.source == "oracle":        W_oracle = torch.as_tensor(B_true, dtype=torch.double, device="cpu")        I_full = get_no_trek_pairs(W_oracle, seq="exp")        I_full = _as_pairs_array(I_full)    else:        raise ValueError("ISpec.source must be one of {'oracle','pairwise'}.")    I = cap_pairs(I_full, I_spec.cap, cap_seed=I_spec.cap_seed)    if verbose and I.shape[0] != I_full.shape[0]:        print(f"I capped: {I_full.shape[0]} â†’ {I.shape[0]} pairs")        print("full:", I_full.tolist())        print("kept:", I.tolist())    return I_full, Iif __name__ == "__main__":    import matplotlib.pyplot as plt    import networkx as nx    rng = np.random.default_rng(2)    d = 5    B = (rng.random((d, d)) < 0.25).astype(np.int64)    np.fill_diagonal(B, 0)    # --- SEM data consistent with B ---    from src.data.sem import simulate_parameter, simulate_linear_sem    np.random.seed(2)    W = simulate_parameter(B)    X = simulate_linear_sem(W, n=100, sem_type="gauss")    # --- Plot ONLY the graph ---    G = nx.from_numpy_array(B, create_using=nx.DiGraph)    pos = nx.spring_layout(G, seed=0)    plt.figure(figsize=(4, 4))    nx.draw(G, pos, with_labels=True, node_size=700, arrows=True)    plt.title("True graph B")    plt.tight_layout()    plt.show()    # --- Minimal terminal summary ---    def show(name, spec):        I_full, I = build_I_full_and_capped(X=X, B_true=B, I_spec=spec)        print(f"{name:8s} | full={len(I_full):3d}  cap={len(I):3d}  {I.tolist()}")    print("\nIndependence summary")    print(f"d={d}, edges={int(B.sum())}")    print(B)    print()    show("pairwise", ISpec(source="pairwise"))    show("oracle",   ISpec(source="oracle", ))